# @(#)[:Ap$)AX3uRfcc&*eNcFG&: 2017/07/08 02:51:18 tw@csongor.lan]
# vim: filetype=zsh tabstop=4 textwidth=72 noexpandtab nowrap

# SYNOPSIS: Create all of the needed variables and functions.
# TODO: start/stop(pause)/skip/quit/finish-song-then-quit

emulate -L zsh
setopt local_options local_traps pipe_fail bsd_echo

needs aucat audioctl autopage awk ffmpeg mediainfo sed sqlite3
needs ${LOCALBIN}/watch-file fullstop :-:amuse-env requires-write

:-:amuse-env # set the environment

test -f $amuse_db   || die "No such file %B${amuse_db:gs/%/%%}%b."
test -f $amuse_bin  || die "No such file %B${amuse_bin:gs/%/%%}%b."
# requires-write expects variable names not their expansion
requires-write	now_playing paused_at paused_song missing_bytes \
				repeat amuse_pid fflog music_list

test -s $music_list || cat > $music_list <<----
	; vim: ft=lst nospell nowrap fo-=a tw=0
	---

function msecToHMMSS {
	integer msecs=$(($1%1000)) seconds=$(($1/1000)) minutes=0 hours=0
	((minutes=seconds/60,seconds%=60))
	((hours=minutes/60,minutes%=60))
	if ((hours)); then
		printf '%d:%0.2d:%0.2d.%0.3d' $hours $minutes $seconds $msecs
	else
		printf '%d:%0.2d.%0.3d' $minutes $seconds $msecs
	fi
}

function a1 {
	setopt local_options local_traps

	local song=$1 atTime=${2:-0.000}
	((atTime))|| : >$missing_bytes # clear if we're starting over
	[[ $song == /* ]]|| song=${XDG_MUSIC_DIR}/$song
	[[ -r $song ]]|| fullstop "Can't play song."

	print -Pu 2 '  %F{4}>>>%f '${${${song#$XDG_MUSIC_DIR/}%.*}:gs/%/%%}
	# clean up last times mess
	: >$paused_song
	: >$paused_at
	# set up device (if possible)
	local minf=( $(mediainfo --Output='Audio;%SamplingRate% %Channels%') )
	audioctl -q rate=${minf[1]:41000} play.channels=${minf[2]:-2} 2>/dev/null
	# get actual device settings and use those for best efficiency
	local cfg=( $(audioctl -n rate play.channels encoding) )
	local ffopts=( -y -loglevel 'error' -ar $cfg[1] -ac $cfg[2] -f $cfg[3] - )
	local auopts=( -f snd/0 -r $cfg[1] -e $cfg[3] -h raw -i - )

	echo ${song#$XDG_MUSIC_DIR/} > $now_playing
	( # workaround to keep zsh from printing job information to tty
		jobs -Z $amusePlayerId
		integer audio_pipe_pid=0
		# PAUSE (stop but save position, can be used for STOPping too).
		function TRAPHUP TRAPINT TRAPQUIT TRAPABRT TRAPKILL TSTP {
			float -F 3 bytes secs
			float rate=$cfg[1] chans=$cfg[2] bps=${${cfg[3]#[fsu]}%[bl]e}
			audioctl -n play.bytes | read bytes
			cat $now_playing >$paused_song
			((secs=bytes/(rate*chans*(bps/8.0))))
			echo $secs >$paused_at
			echo $((bytes+${$(<$missing_bytes):-0})) >$missing_bytes
			kill $audio_pipe_pid
		}
		# SKIP the rest of this song.
		function TRAPUSR1 { kill $audio_pipe_pid; }
		ffmpeg -ss $atTime -i $song $ffopts 2>>$fflog |
			aucat $auopts &
		audio_pipe_pid=$! # name needed for the trap function
		wait $audio_pipe_pid
		: >$amuse_pid
		: >$now_playing
	)&!
	echo $! >$amuse_pid
	${LOCALBIN}/watch-file $amuse_pid
	: > $now_playing
}

function d {
	if (($#)); then
		typeset -- key="$*" NL=$'\0'
		# escape quotes for SQL
		key="${key//\'/\'\'}"

		sqlite3 $amuse_db <<---- | read -r -d$'\x00'
			SELECT replace(replace( performer,   '\','\\'),'${NL}','\n'),
				   replace(replace( album,       '\','\\'),'${NL}','\n'),
				   replace(replace( title,       '\','\\'),'${NL}','\n'),
				                    duration
		  	FROM mediainfo
		 	WHERE title LIKE '%${key}%'
			;
		---
		local i=( "${(f)RESULT}" );

	else
		local f="$(<$now_playing)"
		[[ -s $f ]]|| fullstop 'No current song.'
		local o=( Performer Album Title Duration )
		local i=(
			"$(mediainfo --Output='General;%'${(j:%|%:)o}'%' $f)"
		  )
	fi
	local s=() secs=''
	for I in $i; do
		s=( "${(@s.|.)I}" )
		secs=${s[4]:-\?}
		[[ $secs == \? ]]|| secs=$(msecToHMMSS $s[4])
		printf '  %s (%s) %s\n' ${s[3]:-\?} ${s[1]:-\?} $secs
	done
}

function t {
	needs ${amuse_home}/prac/time-played
	echo
	echo
	export missing_bytes paused_at
	${amuse_home}/prac/time-played
}

function \\dequeue {
	local c=()
	local t=( ${(f)"$(<$music_list)"} )
	local s=$t[1]
	while [[ $s == ';'* ]]; do
		c+=($s)
		shift t
		s=$t[1]
	done
	[[ -n $s ]]|| fullstop 'Queue is empty'

	[[ $s == /* ]]|| s=${XDG_MUSIC_DIR}/$s
	printf '%s' $s
	printf '%s\n' ${(F)c} ${(F)t[2,-1]} >$music_list
  }

function + \\queue {
	local reply
	:-:music-in-fs $@
	printf '%s\n' ${(F)reply} >>$music_list
  }

function ++ \\push {
	local reply
	:-:music-in-fs $@
	local c=()
	local t=( ${(f)"$(<$music_list)"} )
	local s=$t[1]
	while [[ $s == ';'* ]]; do
		c+=($s)
		shift t
		s=$t[1]
	done
	[[ -n $s ]]&& t=( $s $t )
	printf '%s\n' ${(F)c} ${(F)reply} ${(F)t[2,-1]} >$music_list
}

function \\next-song {
	if [[ -s $repeat ]]; then
		: >$repeat
	else
		typeset -g $1="$(\\dequeue)"
	fi
}

function p {

	# resume if there is anything to resume
	[[ -s $paused_at ]]&& {
		if (($#)); then
			yes-or-no 'Continue previously paused song'
			((!?))&&
				a1 "$(<$paused_song)" $(<$paused_at)
		else
			a1 "$(<$paused_song)" $(<$paused_at)
		fi
	}

	# push any new songs
	(($#))&& \\push "$@"

	# then play the list!
	local s; \\next-song s
	while [[ -n $s ]]; do
		a1 $s
		[[ -s $paused_at ]]&& return # stop if we asked to stop
		if [[ -s $repeat ]]; then
			: >$repeat
		else
			\\next-song s
		fi
	done
  }

function l {
	typeset -a pgm=(
		'/^; =[^=]+=/'
			'{ sub("^[^=]*=", ""); sub("=.*$",""); print "#", $0; }'
		'/^;/' '{ next; }'
		'NF==3'
			'{'
				'if ($1 != group) { group=$1; album=""; print "  "group; }'
				'if ($2 != album) { album=$2; print "      "album; }'
				'sub( "\.[^.]+$", "", $3 );'
				'print "          "$3;'
				'next;'
			'}'

	  )
	autopage awk -F'/' "$pgm"  "$music_list"
}

function \\LG {
	declare -a get_groups_awk_pgm=(
		'/^[^;]/'	'{ bands[$1]; }'
		'END'		'{ for (b in bands) print "  "b; }'
	  )
	awk -F/ "$get_groups_awk_pgm" $music_list
}
function lg { autopage \\LG; }
function L { local s; for s; do \\queue ${music_dir}/${s}*; done; }

function N {
	typeset -- marker='^; =.=$'
	typeset -- current="$( awk -F= "/$marker/ { print \$2; }" $music_list )"
	typeset -i asc=$(( $(printf '%d' \'$current) + 1 ))
	typeset -- next=$( printf "\x$(printf '%x\n' $asc)" )
	L $next
	typeset -- sponge=$(sed -e "s/$marker/; =$next=/" $music_list)
	cat <<<$sponge  >$music_list
	lg
}

function v {
	vim $music_list
	lg
}

function h {
	typeset B=$'\e[1m';		b=$'\e[22m'
	typeset S=$'\e[34m';	s=$'\e[39m'
	typeset N=$'\e[0m'
	cat <<----
	  a  => play songs given on command line.
	  +  => append songs from the paths given on command line ${B}togo.lst${b}
	  ++ => like ${B}+${b}, except prepend.
	  d  => show info for song on command line.
	  t  => show time played for song playing.
	  p  => play songs in ${B}togo.lst${b}.
	  l  => list songs in ${B}togo.lst${b}
	  L  => make a new ${B}togo.lst${b} from \$music_dir/\${1}*/*/*
	  N  => make a new ${B}togo.lst${b} using *next* letter in alphabet for ${S}L${s}
	  l  => list songs in ${B}togo.lst${b}
	  lg => list groups in ${B}togo.lst${b}
	  r  => renew ${B}amuse${b} functions from \$Z/functions/amuse
	  v  => edit ${B}togo.lst${b}
	  u  => unset all of the special amuse bits
	---
}

function cd { (($#))|| set $music_dir; builtin cd "$@"; }
function r { . $Z/functions/amuse; }
function u {
	warn 'Removing %F{4}amuse%f functions.'
	set_prompt
	unset -f + ++ L N \\LG \\dequeue \\push \\queue a1 d h l lg p r t u v
	unset -f amuse cd msecToHMMSS
	function amuse { builtin autoload -XUz; }
	cd $PRE_AMUSE_PWD
}


PS1='%K{3}%F{7}%B amuse %b%f%k%s '
PRE_AMUSE_PWD=${PRE_AMUSE_PWD:-$PWD}
cd $music_dir

# Copyright Â© 2017 by Tom Davis <tom@greyshirt.net>.
